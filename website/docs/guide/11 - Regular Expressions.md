---
title: Regular Expressions
sidebar_position: 11
---

The sort constructor `RegEx` takes as argument a sequence type.
The set of regular expressions over strings is thus `(RegEx String)`; 
it is synomumous with the sort `RegLan` defined in the [SMTLIB2 format](http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml).

# Summary of Operations

   Operation                    | Brief Description
|-------------------------------|------------------------|
<tt>(str.to.re s)</tt>          | Convert string to regular expression accepting <tt>s</tt>
<tt>(str.in.re s r)</tt>        | Determine if <tt>s</tt> is in the language generated by <tt>r</tt>
<tt>re.allchar</tt>             | The regular expression accepting every string
<tt>re.nostr</tt>               | The regular expression rejecting every string
<tt>(re.range ch1 ch2)</tt>     | The range of characters (represented as strings) between <tt>ch1</tt> and <tt>ch2</tt>
<tt>(re.++ r1 r2 r3)</tt>       | Concatenation of regular expressions
<tt>(re.* r)</tt>               | Kleene star
<tt>(re.+ r)</tt>               | Kleene plus
<tt>(re.opt r)</tt>             | Zero or one use of <tt>r</tt>
<tt>((_ re.loop lo hi) r)</tt>  | from <tt>lo</tt> to <tt>hi</tt> number of repetitions of <tt>r</tt>
<tt>(re.union r1 r2)</tt>       | The union of regular languages
<tt>(re.inter r1 r2)</tt>       | The intersection of regular languages
<tt>(seq.to.re s)</tt>          | Convert sequence to regular expression accepting <tt>s</tt>
<tt>(seq.in.re s r)</tt>        | Determine if sequence <tt>s</tt> is in the language generated by <tt>r</tt>
<tt>(as re.all R)</tt>          | The regular expression of sort <tt>R</tt> accepting every sequence
<tt>(as re.empty R)</tt>        | The regular expression of sort <tt>R</tt> rejecting every sequence

The `re.range` operator expects two strings each encoding a single character.
For example `(re.range "a" "\u{ff}")` is a valid range of characters, 
while `(re.range "aa" "")` is the empty language. 

```z3
(simplify (re.range "a" "\u{ff}"))
(simplify (re.range "aa" ""))
```

For  compatibility with the SMTLIB2 format 
Z3 also accepts expressions of the form `(re.loop r lo hi)`.
Z3 understands only the meaning of these terms when `lo, hi` are 
integer numerals.

# What (not) to expect of regular expressions
The default solver for regular expressions unfolds membership relations of regular expressions lazily.
It uses [symbolic derivatives](https://dl.acm.org/doi/abs/10.1145/3453483.3454066) .
This approach works for many membership and non-membership constraints, but is not a complete 
procedure when membership constraints are combined with constraints over strings.
Note that the syntax allows forming _symbolic_ regular expressions that contain uninterpreted non-terminals.
It also does not handle regular expressions symbolic sequences (it allows
to express non-regular languages).
Thus, the string <tt>s</tt> in <tt>(str.to.re s)</tt> should be 
a string literal. You can write formulas with equalities over 
regular expressions. Z3 is a decision procedure for equalities and disequalities between non-symbolic regular expressions.

# Examples

The maximal length is 6 for a string of length 2 repeated at most 3 times.

```z3
(declare-const a String)
(push)
(set-info :status sat)
(assert (str.in.re a ((_ re.loop 1 3) (str.to.re "ab"))))
(assert (= (str.len a) 6))
(check-sat)
(get-model)
(pop)

(push)
(set-info :status unsat)
(assert (str.in.re a ((_ re.loop 1 3) (str.to.re "ab"))))
(assert (> (str.len a) 6))
(check-sat)
(pop)
```
 
